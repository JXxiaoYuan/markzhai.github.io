<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="ieCGPLaYJPLAp6By_5652iPczS2GIfAPy9XGEkD6-e0" />




  <meta name="baidu-site-verification" content="780t5iFaTK" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,PWA,React.js,前端," />





  <link rel="alternate" href="/atom.xml" title="markzhai's home" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="原文地址：Progressive Web Apps with React.js: Part 2 — Page Load Performance
原文作者：Addy Osmani
译文出自：掘金翻译计划
译者：markzhai
校对者：


使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能新 系列 的第二部分会完整地走一遍怎么使用 Lighthouse. 来优化移动">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能">
<meta property="og:url" content="http://blog.zhaiyifan.cn/2010/11/14/pwa-react-p2/index.html">
<meta property="og:site_name" content="markzhai's home">
<meta property="og:description" content="原文地址：Progressive Web Apps with React.js: Part 2 — Page Load Performance
原文作者：Addy Osmani
译文出自：掘金翻译计划
译者：markzhai
校对者：


使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能新 系列 的第二部分会完整地走一遍怎么使用 Lighthouse. 来优化移动">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/0*KlJk2hhZl3wyn6E4.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*qfZvSxxJxPHhXXgb.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/0*N--j53GygKHn2ViI.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*55ArR_Z3qt7Az_FW.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*z2tqS124xW0GDmcP.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/0*c9rmq2rp95BN39qg.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*l-XqjMw7_XX0wsxX.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*glKcFK9_RLNk9AyR.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*tVvolw4FTKjNFAnY.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*QphlrnwHQiOsB06w.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*YMvoz-W2HL3v2MIs.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*D5j-Jv_FVkMigRyZ.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/0*2XxuNsDEp1-4VuoU.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/0*-llrY94drXMjBUW6.">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/0*-hLp_Acvig_s4Uop.">
<meta property="og:updated_time" content="2016-11-14T15:28:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能">
<meta name="twitter:description" content="原文地址：Progressive Web Apps with React.js: Part 2 — Page Load Performance
原文作者：Addy Osmani
译文出自：掘金翻译计划
译者：markzhai
校对者：


使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能新 系列 的第二部分会完整地走一遍怎么使用 Lighthouse. 来优化移动">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '13060344',
      author: 'MarkZhai'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>







  <title> 使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能 | markzhai's home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-67533211-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?74dc0d49be7a61e341f6c897ee4d733a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">markzhai's home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://blog.zhaiyifan.cn/2010/11/14/pwa-react-p2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Mark Zhai (翟一帆)">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="markzhai's home">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="markzhai's home" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Дата создания записи" itemprop="dateCreated datePublished" datetime="2010-11-14T23:26:28+08:00">
              2010-11-14
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Дата обновления записи" itemprop="dateModified" datetime="2016-11-14T23:28:00+08:00">
              2016-11-14
            </time>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frontend/" itemprop="url" rel="index">
                    <span itemprop="name">Frontend</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2010/11/14/pwa-react-p2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2010/11/14/pwa-react-p2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2#.o0f4vf64s" target="_blank" rel="external">Progressive Web Apps with React.js: Part 2 — Page Load Performance</a></li>
<li>原文作者：<a href="https://medium.com/@addyosmani" target="_blank" rel="external">Addy Osmani</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/markzhai" target="_blank" rel="external">markzhai</a></li>
<li>校对者：</li>
</ul>
</blockquote>
<h1 id="使用_React-js_的渐进式_Web_应用程序：第_2_部分_-_页面加载性能">使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能</h1><h2 id="新_系列_的第二部分会完整地走一遍怎么使用_Lighthouse-_来优化移动_web_apps。这篇文章，我们来看看页面加载性能。">新 <a href="https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-i-introduction-50679aef2b12#.ysn8uhvkq" target="_blank" rel="external">系列</a> 的第二部分会完整地走一遍怎么使用 <a href="https://github.com/googlechrome/lighthouse" target="_blank" rel="external">Lighthouse.</a> 来优化移动 web apps。这篇文章，我们来看看页面加载性能。</h2><h3 id="保证页面加载性能是快的">保证页面加载性能是快的</h3><p>移动 Web 的速度很关键。平均地，更快的体验会带来 <a href="https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/" target="_blank" rel="external">70% 更长的会话</a> 以及两倍以上更多的移动广告收益。Web 性能的投资像是基于 React 的 Flipkart Lite <a href="https://developers.google.com/web/showcase/2016/flipkart" target="_blank" rel="external">获得了三倍网站浏览时间</a>， GQ 在流量上得到了 <a href="http://digiday.com/publishers/gq-com-cut-page-load-time-80-percent/" target="_blank" rel="external">80% 增长</a>，Trainline 在 <a href="https://youtu.be/ai-6qwT6ES8?t=462" target="_blank" rel="external">年收益上增长了 11M</a> 并且 Instagram <a href="http://engineering.instagram.com/posts/193415561023919/performance-&amp;-usage-at-Instagram" target="_blank" rel="external">增长了 33% 的印象</a>.</p>
<p>在你的 web app 加载时有一些 <a href="https://www.youtube.com/watch?v=wFwogd4CdwY&amp;index=4&amp;list=PLNYkxOF6rcIB3ci6nwNyLYNU6RDOU3YyL" target="_blank" rel="external">关键的用户时刻</a>：</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/0*KlJk2hhZl3wyn6E4." alt=""></p>
<p>测量然后优化总是关键的。Lighthouse 的页面加载检测会关注：</p>
<ul>
<li><a href="https://www.quora.com/What-does-First-Meaningful-Paint-mean-in-Web-Performance" target="_blank" rel="external"><strong>第一次有意义的绘制</strong></a>（当页面主内容可见）</li>
<li><a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="external"><strong>速度指数（Speed Index）</strong></a>（可见区域完整）</li>
<li><strong>估算的输入延迟</strong>（当主线程可以立即处理用户输入）</li>
<li>以及 <strong>抵达可交互的时间</strong>（app 多快达到可用可参与)</li>
</ul>
<p><strong>顺带一提，Paul Irish 做了很了不起的相关总结 <a href="https://www.youtube.com/watch?v=IxXGMesq_8s" target="_blank" rel="external">PWAs 的有趣指标</a>值得一看。</strong></p>
<p><strong>良好性能的目标：</strong></p>
<ul>
<li><strong>遵循</strong> <a href="https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/rail?hl=en" target="_blank" rel="external"><strong>RAIL 性能模型</strong></a> 的 L 部分。<strong> A+ 的性能是我们所有人都必须力求达到的，即便有的浏览器不支持 Service Worker。我们仍然可以快速地在屏幕上获得一些有意义的内容，并且仅加载我们所需要的</strong></li>
<li><strong>在典型网络（3G）和硬件条件下</strong></li>
<li>首次访问在 5 秒内可交互，重复访问（Service Worker 可用）则在 2 秒内。</li>
<li>首次加载（网络限制下），速度指数在 3000 或者更少。</li>
<li>第二次加载（磁盘限制，因为 Service Worker 可用）：速度指数 1000 或者更少。</li>
</ul>
<p>让我们再说说，关于通过 TTI 关注交互性。</p>
<h3 id="关注抵达可交互时间（TTI）">关注抵达可交互时间（TTI）</h3><p>为交互性优化，也就是使得 app 尽快能对用户可用（比如让他们可以四处点击，app 可以相应）。这对试图在移动设备上提供一流用户体验的现代 web 体验很关键。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*qfZvSxxJxPHhXXgb." alt=""></p>
<p>Lighthouse 现在将 TTI 测量为布局稳定，web 字体可见，并且主线程可以响应用户输入的时间。有很多方法来手动跟踪 TTI，重要的是根据指标进行优化会提升你用户的体验。</p>
<p>对于像 React 这样的库，你应该关心的是在移动设备上 <a href="https://aerotwist.com/blog/the-cost-of-frameworks/" target="_blank" rel="external">启用库的代价</a> 因为这会让人们有感知。在 <a href="https://github.com/insin/react-hn" target="_blank" rel="external">ReactHN</a>，我们达到了 <strong>1700毫秒</strong> 内可交互，通过保持整个 app 的大小和执行代价相对小，撇开有多个视图：app bundle gzipped 压缩后 11KB，107KB 用于我们的 vendor/React/库 bundle，实践中有点像这样：</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/0*N--j53GygKHn2ViI." alt=""></p>
<p>之后，对于功能颗粒状的 apps，我们会看看性能模式像是 <a href="https://www.polymer-project.org/1.0/toolbox/server" target="_blank" rel="external">PRPL</a>，通过在 <a href="https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/" target="_blank" rel="external">HTTP/2 服务器 Push</a> 下利用颗粒状的 “基于路由的分块” 来得到快速的可交互时间。（可以试试 <a href="https://shop.polymer-project.org/" target="_blank" rel="external">Shop</a> demo 来看看我们说的是什么）。</p>
<p>Housing.com 最近使用了类 PRPL 模式搭载 React 体验，获得了很多赞扬：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*55ArR_Z3qt7Az_FW." alt=""></p>
<p>Housing.com 利用 Webpack 路由分块，来推迟入口页面的部分启动消耗（仅加载 route 渲染所需要的）。更多细节请查看 <a href="https://twitter.com/samccone/status/771786445015035904" target="_blank" rel="external">Sam Saccone 的优秀 Housing.com 性能检测</a>.</p>
<p>Flipkart 也做了类似的：</p>
<p>注意：关于什么是 “到可交互时间”，有很多不同的看法，Lighthouse 对 TTI 的定义也可能会演变。其他跟踪的方法有导航后第一个 5 秒内 window 没有长任务的时刻，或者一次文本/内容绘制后第一次 5 秒内 window 没有长任务的时刻。基本上，就是页面稳定后多快，用户可以和 app 交互的。</p>
<p>注意：尽管不是强制的要求，你可能也需要提高视觉完整度（速度指数），通过 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="external">优化关键渲染路径</a>。<a href="https://github.com/addyosmani/critical-path-css-tools#node-modules" target="_blank" rel="external">关键路径 CSS 优化工具的存在</a> 以及其优化在 HTTP/2 的世界中依然有效。</p>
<h3 id="基于路由分块以提高性能">基于路由分块以提高性能</h3><h3 id="Webpack">Webpack</h3><p><strong>如果你第一次接触模块打包工具像是 Webpack，看看</strong> <a href="https://www.youtube.com/watch?v=OhPUaEuEaXk" target="_blank" rel="external"><strong>JS 模块化打包器</strong></a><strong>(视频) 可能会有帮助。</strong></p>
<p>一些今天的 JavaScript 工具使得将你的所有脚本打包成一个 bundle.js 文件并包含所有页面变得简单。这意味着很多时候，你可能要加载很多对当前路由来说并不需要的代码。为什么一次路由需要加载 500KB 的 JS，而事实上 50KB 就够了呢？我们应该丢开那些无助于获得更快体验的脚本，来加速获得可交互的路由。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*z2tqS124xW0GDmcP." alt=""></p>
<p><strong>当仅提供用户一次 route 所需要的最小功能可达代码就可以的时候，避免提供庞大整块的 bundles（像上图）。</strong></p>
<p>代码分割是解决整块的 bundles 的一个方法。想法大致是在你的代码中定义分割点，然后分割成不同的文件进行按需懒加载。这会提升启动时间，帮助我们更快地可交互。</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/0*c9rmq2rp95BN39qg." alt=""></p>
<p>想象使用一个公寓列表 app。如果我们登陆的路由是列出我们所在区域的地产（route-1）—— 我们不需要查看完整的地产详情的代码（route-2）或者预约一次看房（route-3），所以我们可以仅提供用户列表路由所需要的 JavaScript，然后动态加载剩下的。</p>
<p>这些年来，代码分割的想法已经被很多 apps 使用，但现在用 “<a href="https://gist.github.com/addyosmani/44678d476b8843fd981ff8011d389724" target="_blank" rel="external">基于路由的分块</a>” 来称呼它。通过 Webpack 模块打包器，我们可以启用 React 上的安装。</p>
<h3 id="实践基于路由的代码分块">实践基于路由的代码分块</h3><p>Webpack 支持当它发现一个 <a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">require.ensure()</a> 被使用的时候将你的 app 代码分割成块（或者在 <a href="https://gist.github.com/sokra/27b24881210b56bbaff7" target="_blank" rel="external">Webpack 2</a>，一个 <a href="http://moduscreate.com/code-splitting-for-react-router-with-es6-imports/" target="_blank" rel="external">System.import</a>)。这些被称为 “分割点”，Webpack 会对它们的每一个都生成一个分开的 bundlea，按需解决依赖。</p>
<pre><code><span class="comment">// 定义一个 "split-point"</span>
<span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
   <span class="keyword">const</span> details = <span class="built_in">require</span>(<span class="string">'./Details'</span>);
   <span class="comment">// 所有被 require() 需要的都会成为分开的 bundle</span>
   <span class="comment">// require(deps, cb) 是异步的。它会异步加载，并且评估</span>
   <span class="comment">// 模块，通过你的 deps 的 exports 调用 cb。</span>
});
</code></pre><p>当你的代码需要某些东西，Webpack 会发起一个 JSONP 请求来从服务器获得它。这个和 React Router 结合工作得很好，我们可以在对用户渲染视图之前在依赖（块）中懒加载一个新的路由。<br>When your code needs something, Webpack makes a JSONP call to fetch it from the server. This works well with React Router and we can lazy-load in the dependencies (chunks) a new route needs before rendering the view to a user.</p>
<p>Webpack 2 支持 <a href="https://medium.com/modus-create-front-end-development/automatic-code-splitting-for-react-router-w-es6-imports-a0abdaa491e9#.3ryyedhfc" target="_blank" rel="external">使用 React Router 的自动代码分割</a> 因为它可以处理模块上的 System.import 调用为 import 语句，将导入的文件和它们的依赖一起打包。依赖不会与你在 Webpack 设置中的初始入口冲突。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../containers/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorLoading</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Lazy-loading failed'</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadRoute</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">module</span>) =&gt; cb(<span class="literal">null</span>, <span class="built_in">module</span>.default);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  component: App,</span><br><span class="line">  childRoutes: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'booktour'</span>,</span><br><span class="line">      getComponent(location, cb) &#123;</span><br><span class="line">        System.import(<span class="string">'../pages/BookTour'</span>)</span><br><span class="line">          .then(loadRoute(cb))</span><br><span class="line">          .catch(errorLoading);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="附录：预加载那些路由！">附录：预加载那些路由！</h3><p>在我们继续之前，除了刚才的方法，另一个可选的是 <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="external"></a> 来自 <a href="https://twitter.com/addyosmani/status/743571393174872064" target="_blank" rel="external">Resource Hints</a>。这个提供给我们一个方法来宣告式地获取资源而不执行它们。预加载可以用来预加载用户<strong>可能</strong>要去的路由所需要的 Webpack 块，于是缓存已经为他们准备好了，可以在需要的时候立即可用。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*l-XqjMw7_XX0wsxX." alt=""></p>
<p>在写的时候，预加载只能在 <a href="http://caniuse.com/#feat=link-rel-preload" target="_blank" rel="external">Chrome</a> 中进行，但是在支持的浏览器中被处理为渐进式增加。</p>
<p>注意：html-webpack-plugin 的 <a href="https://github.com/ampedandwired/html-webpack-plugin#events" target="_blank" rel="external">模板和自定义事件</a> 可以使用最小的改变来让简化这个过程。然后你应该保证预加载的资源真正会对你大部分的用户浏览过程有用。</p>
<h3 id="异步加载路由">异步加载路由</h3><p>让我们回到代码分割（code-splitting）—— 在一个使用 React 和 <a href="https://github.com/reactjs/react-router" target="_blank" rel="external">React Router</a> 的 app 里，我们可以使用 require.ensure() 以在 ensure 被调用的时候异步加载一个组件。顺带一提，如果任何人在探索服务器渲染，这个在 Node 里需要被 <a href="https://www.npmjs.com/package/node-ensure" target="_blank" rel="external">node-ensure</a> 包来填充。Pete Hunt 在 <a href="https://github.com/petehunt/webpack-howto#9-async-loading" target="_blank" rel="external">Webpack How-to</a> 涵盖了异步加载。</p>
<p>在下面的例子里，require.ensure() 使我们可以按需懒加载路由，在组件被使用前等待拉取：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootRoute = &#123;</span><br><span class="line">  component: Layout,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  indexRoute: &#123;</span><br><span class="line">    getComponent (location, cb) &#123;</span><br><span class="line">      <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./Landing'</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  childRoutes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'book'</span>,</span><br><span class="line">      getComponent (location, cb) &#123;</span><br><span class="line">        <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">          cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./BookTour'</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'details/:id'</span>,</span><br><span class="line">      getComponent (location, cb) &#123;</span><br><span class="line">        <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">          cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./Details'</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：我经常通过 CommonChunksPlugin（minChunks：<br>Infinity）来进行上面的安装，所以在我不同的入口点之间有一个带有通用模块的 chunk。这也 <a href="https://github.com/webpack/webpack/issues/368#issuecomment-247212086" target="_blank" rel="external">极力降低了</a> 陷入缺省 Webpack runtime 的可能。</strong></p>
<p>Brian Holt 在 <a href="https://btholt.github.io/complete-intro-to-react/" target="_blank" rel="external">React 的完整介绍</a> 对异步路由加载涵盖得很好。通过异步路由的代码分割在 React Router 的目前版本和 <a href="https://gist.github.com/acdlite/a68433004f9d6b4cbc83b5cc3990c194" target="_blank" rel="external">新的 React Router V4</a> 都可以使用。</p>
<h3 id="通过异步的_getComponent_+_require-ensure()_的简单宣告式路由分块">通过异步的 getComponent + require.ensure() 的简单宣告式路由分块</h3><p>这有有一个小贴士，可以使代码分割的安装更快。在 React Router，一个 <a href="https://github.com/ReactTraining/react-router/blob/master/docs/API.md#route" target="_blank" rel="external">宣告式的路由</a> 来将路由 “/” 映射到组件 <code>App</code> 看上去像 <code>&lt;Route path=”/” component={App}&gt;</code>.</p>
<p>React Router 也支持一个方便的 <code>[getComponent](https://github.com/ReactTraining/react-router/blob/master/docs/API.md#getcomponentnextstate-callback)</code> 属性，类似于 <code>component</code> 但却是异步的，对快速安装上代码分割<strong>超级有用</strong>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">   path=<span class="string">"stories/:storyId"</span></span><br><span class="line">   getComponent=&#123;(nextState, cb) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 异步地查找 components</span></span><br><span class="line">  cb(<span class="keyword">null</span>, Stories)</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>getComponent</code> 函数参数包括下一个状态（我设置为 null）和一个回调。</p>
<p>让我们添加一些基于路由的代码分割到 <a href="https://github.com/insin/react-hn" target="_blank" rel="external">ReactHN</a>。我们会从 <a href="https://github.com/insin/react-hn/blob/master/src/routes.js#L36" target="_blank" rel="external">routes</a> 文件中的一段开始 —— 它定义了组件的 require 调用和对每个路由的 React Router 路由（比如 news, item, poll, job, comment 永久链接等）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IndexRoute = <span class="built_in">require</span>(<span class="string">'react-router/lib/IndexRoute'</span>)</span><br><span class="line"><span class="keyword">var</span> App = <span class="built_in">require</span>(<span class="string">'./App'</span>)</span><br><span class="line"><span class="keyword">var</span> Item = <span class="built_in">require</span>(<span class="string">'./Item'</span>)</span><br><span class="line"><span class="keyword">var</span> PermalinkedComment = <span class="built_in">require</span>(<span class="string">'./PermalinkedComment'</span>) &lt;--</span><br><span class="line"><span class="keyword">var</span> UserProfile = <span class="built_in">require</span>(<span class="string">'./UserProfile'</span>)</span><br><span class="line"><span class="keyword">var</span> NotFound = <span class="built_in">require</span>(<span class="string">'./NotFound'</span>)</span><br><span class="line"><span class="keyword">var</span> Top = stories(<span class="string">'news'</span>, <span class="string">'topstories'</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="xml"><span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"/"</span> <span class="attribute">component</span>=<span class="value">&#123;App&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">IndexRoute</span> <span class="attribute">component</span>=<span class="value">&#123;Top&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"news"</span> <span class="attribute">component</span>=<span class="value">&#123;Top&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"item/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;Item&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"job/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;Item&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"poll/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;Item&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"comment/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;PermalinkedComment&#125;</span>/&gt;</span> <span class="tag">&lt;<span class="title">---</span></span><br><span class="line">  &lt;<span class="attribute">Route</span> <span class="attribute">path</span>=<span class="value">"newcomments"</span> <span class="attribute">component</span>=<span class="value">&#123;Comments&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"user/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;UserProfile&#125;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"*"</span> <span class="attribute">component</span>=<span class="value">&#123;NotFound&#125;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>ReactHN 现在提供给用户一个整块包含<strong>所有</strong>路由的 JS bundle。让我们将它转换为路由分块，只提供一次路由真正需要的代码，从 comment 的永久链接开始（comment/:id）：</p>
<p>所以我们首先删了对永久链接组件的隐式 require：</p>
<pre><code><span class="tag">var</span> PermalinkedComment = <span class="function"><span class="title">require</span><span class="params">(‘./PermalinkedComment’)</span></span>
</code></pre><p>然后开始我们的路由..</p>
<p>然后使用宣告式的 getComponent 来更新它。我们在路由中使用 require.ensure() 调用来懒加载，而这就是我们所需要做的一切了：</p>
<pre><code>&lt;Route
  path=<span class="string">"comment/:id"</span>
  getComponent={(location, callback) =&gt; {
    <span class="keyword">require</span>.ensure([], <span class="keyword">require</span> =&gt; {
      callback(<span class="keyword">null</span>, <span class="keyword">require</span>(<span class="string">'./PermalinkedComment'</span>))
    }, <span class="string">'PermalinkedComment'</span>)
  }}
/&gt;
</code></pre><p>Orz 太美了。这..就搞定了。不骗你。我们可以把这个用到剩下的路由上，然后运行 webpack。它会正确地找到 require.ensure() 调用，然后如我们想要地区分隔代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*glKcFK9_RLNk9AyR." alt=""></p>
<p>在应用宣告式的代码分割到更多我们的路由后，可以看到路由分块在运作，仅仅会加载一次路由所需要的代码（在 Service Worker 可以预缓存起来）：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*tVvolw4FTKjNFAnY." alt=""></p>
<p>提醒：有许多可用于 Service Worker 的简单 Webpack 插件：</p>
<ul>
<li><a href="https://github.com/goldhand/sw-precache-webpack-plugin" target="_blank" rel="external">sw-precache-webpack-plugin</a> which uses sw-precache under the hood</li>
<li><a href="https://github.com/NekR/offline-plugin" target="_blank" rel="external">offline-plugin</a> which is used by react-boilerplate</li>
</ul>
<h4 id="CommonsChunkPlugin">CommonsChunkPlugin</h4><p><img src="https://cdn-images-1.medium.com/max/1600/0*QphlrnwHQiOsB06w." alt=""></p>
<p>为了识别出在不同路由使用的通用模块并把它们放在一个通用的分块，需要使用 <a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin" target="_blank" rel="external">CommonsChunkPlugin</a>。它需要在每个页面 requires 两个 script 标签，一个用于 commons 分块，另一个用于一次路由的入口分块。</p>
<pre><code><span class="keyword">const</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);
<span class="module"><span class="keyword">module</span>.exports = </span>{
    entry: {
        p1: <span class="string">"./route-1"</span>,
        p2: <span class="string">"./route-2"</span>,
        p3: <span class="string">"./route-3"</span>
    },
    output: {
        filename: <span class="string">"[name].entry.chunk.js"</span>
    },
    plugins: [
        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.chunk.js"</span>)
    ]
}
</code></pre><p>Webpack 的 <a href="https://blog.madewithlove.be/post/webpack-your-bags/" target="_blank" rel="external">— display-chunks 标志</a> 对于查看模块在哪个分块中出现很有用。这个帮助我们减少分块中重复的依赖，并且能提示在你的项目中开启 CommonChunksPlugin 是否值得。这是一个带有多个组件的项目，在不同分块间检测到重复的 Mustache.js 依赖：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*YMvoz-W2HL3v2MIs." alt=""></p>
<p>Webpack 1 也支持通过 <a href="https://github.com/webpack/docs/wiki/optimization#deduplication" target="_blank" rel="external">DedupePlugin</a> 以在你的依赖树中进行依赖库的去重。在 Webpack 2，tree-shaking 应该淘汰了这个的需求。</p>
<p><strong>更多 Webpack 的小贴士</strong></p>
<ul>
<li>你的代码库中 require.ensure() 调用的数目通常会关联到生成的 bundles 的数目。在代码库中大量使用 ensure 的时候意识到这点很有用。</li>
<li><a href="https://medium.com/modus-create-front-end-development/webpack-2-tree-shaking-configuration-9f1de90f3233" target="_blank" rel="external">Webpack2 的 Tree-shaking</a> 会帮助删除没用的 exports，这可以让你的 bundle 尺寸变小。</li>
<li>另外，小心避免在 通用/共享的 bundles 里面调用 require.ensure()。你可能会发现这会创建入口点引用，关于那些已经被加载了的依赖的假设。</li>
<li>在 Webpack 2，System.import 目前不支持服务端渲染，但我已经在 <a href="http://stackoverflow.com/a/39088208" target="_blank" rel="external">StackOverflow</a> 分享了怎么去处理这个问题。</li>
<li>如果需要优化编译速度，可以看看 <a href="https://github.com/webpack/docs/wiki/list-of-plugins" target="_blank" rel="external">Dll plugin</a>，<a href="https://www.npmjs.com/package/parallel-webpack" target="_blank" rel="external">parallel-webpack</a> 以及目标的编译。</li>
<li>如果你希望通过 Webpack <strong>异步</strong> 或者 <strong>延迟</strong> 脚本，看看 <a href="https://github.com/numical/script-ext-html-webpack-plugin" target="_blank" rel="external">script-ext-html-webpack-plugin</a></li>
</ul>
<p><strong>在 Webpack 编译中检测臃肿</strong></p>
<p>Webpack 社区有很多建立在 Web 上的编译分析器包括 <a href="http://webpack.github.io/analyse/" target="_blank" rel="external">http://webpack.github.io/analyse/</a>，<a href="https://chrisbateman.github.io/webpack-visualizer/" target="_blank" rel="external">https://chrisbateman.github.io/webpack-visualizer/</a>，和 <a href="https://alexkuz.github.io/stellar-webpack/" target="_blank" rel="external">https://alexkuz.github.io/stellar-webpack/</a>。这些对于理解你最大的模块是什么很有用。</p>
<p><a href="https://github.com/danvk/source-map-explorer" target="_blank" rel="external"><strong>source-map-explorer</strong></a> (来自 Paul Irish) 通过 source maps 来理解代码臃肿，也<strong>超级棒</strong>的。看看这个对 ReactHN Webpack bundle 的 tree-map 可视化，带有每个文件的代码行数，以及百分比的统计分析：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*D5j-Jv_FVkMigRyZ." alt=""></p>
<p>你可能也会对来自 Sam Saccone 的 <a href="https://github.com/samccone/coverage-ext" target="_blank" rel="external"><strong>coverage-ext</strong></a> 感兴趣，它可以用来对任何 webapp 生成代码覆盖率。这个对于理解你的代码中有多少实际会被执行到很有用。</p>
<h3 id="代码分割（code-splitting）之上：PRPL_模式">代码分割（code-splitting）之上：PRPL 模式</h3><p>Polymer 发现了一个有趣的 web 性能模式，用于精细服务的 apps，称为 <a href="https://www.polymer-project.org/1.0/toolbox/server" target="_blank" rel="external">PRPL</a>（看看 <a href="https://www.youtube.com/watch?v=J4i0xJnQUzU" target="_blank" rel="external">Kevin 的 I/O 演讲</a>)。这个模式尝试为交互性优化，并且代表了：</p>
<ul>
<li>(P)ush，对于初始路由推送关键资源。</li>
<li>(R)ender，渲染初始路由，并使它尽快变得可交互。</li>
<li>(P)re-cache，通过 Service Worker 预缓存剩下的路由。</li>
<li>(L)azy-load，根据用户在应用中的移动懒加载并懒初始化 apps 中对应的部分。</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/2000/0*2XxuNsDEp1-4VuoU." alt=""></p>
<p>We have to give great kudos here to the <a href="https://shop.polymer-project.org/" target="_blank" rel="external">Polymer Shop demo</a> for showing us the way on real mobile devices. Using PRPL (in this case with HTML Imports, which can take advantage of the browser’s background HTML parser). No pixels go on screen that you can’t use. Additional work here is chunked and stays interactive. We’re interactive on a real mobile device at 1.75seconds. 1.3s of JavaScript but it’s all broken up. After that it all works.</p>
<p>You’re hopefully on board with the benefits of breaking down applications into more granular chunks by now. When a user first visits our PWA, let’s say they go to a particular route. The server (using H/2 Push) can push down the chunks needed for just that route — these are only the pieces needed to get the application booted up. Those go into the network cache.</p>
<p>Once they’ve been pushed down, we’ve effectively primed the cache with the chunks we know the page will need. When the application boots up, it looks at the route and knows that what we need is already in the cache, so we get that really fast first load of our application — not just a splash screen — but the interactive content the user asked for.</p>
<p>The next part of this is rendering the content for the view as quickly as possible. The third is, while the user is looking at the current view, using Service Worker to start pre-caching all of the other chunks and routes the user hasn’t asked for yet and getting those all installed into the Service Worker cache.</p>
<p>At this point the entire application (or a lot more of it) can be available offline. When a user navigates to a different part of the application, we can lazy load the next parts of it from the Service Worker cache. There’s no network loading needed because they’re already precached. Instant loading awesomeness ahoy! ❤</p>
<p>PRPL can be applied to any app, as Flipkart recently demonstrated on their React stack. Apps fully using PRPL can take advantage of fast-loading using HTTP/2 server push by producing two builds that we conditionally serve depending on your browser support:</p>
<ul>
<li><p>A bundled build optimised to minimize round-trips for servers/browsers without HTTP/2 Push support. For most of us, this is what we ship today by default.</p>
</li>
<li><p>An unbundled build for servers/browsers that do support HTTP/2 Push enabling a faster first-paint</p>
</li>
</ul>
<p>This builds on some of the thinking we talked about earlier with route-chunking. With PRPL, the server and our Service Worker work together to precache resources for intactive routes. When a user navigates around your app and changes routes, we lazy-load resources for routes not cached yet and create the required views.</p>
<h3 id="实现_PRPL">实现 PRPL</h3><p><strong>太长了，所以没有看：Webpack 的 require.ensure() 以及异步的 ‘getComponent’，还有 React Router 是到 PRPL 风格性能模式的最小摩擦路径</strong></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*-llrY94drXMjBUW6." alt=""></p>
<p>PRPL 的一大部分在于将 JS 捆包思维方式放下，并像编写时候那样精细地传输资源（至少从功能独立模块角度上）。通过 Webpack，这就是我们已经说过的路由分块。</p>
<p>对于初始路由推送关键资源。理想情况下，使用 <a href="https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/" target="_blank" rel="external">HTTP/2 服务端推送</a>，但即便没有它，也不会成为实现类 PRPL 路径的阻碍。即便没有 H/2 推送，你也可以实现一个大致和“完整” PRPL 类似的结果，只需要发送 <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="external">预加载头</a> 而不需要 H/2。</p>
<p>看看 Flipkart 他们前后的生产瀑布：</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/0*-hLp_Acvig_s4Uop." alt=""></p>
<p>Webpack 已经通过 <a href="https://github.com/webpack/webpack/tree/master/examples/http2-aggressive-splitting" target="_blank" rel="external">AggressiveSplittingPlugin</a> 的形式支持了 H/2。</p>
<p>AggressiveSplittingPlugin 分割每个块直到它到达了指定的 maxSize，正如我们在下面的例子里可见的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./example"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">"js"</span>),</span><br><span class="line">        filename: <span class="string">"[chunkhash].js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[chunkhash].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.AggressiveSplittingPlugin(&#123;</span><br><span class="line">            minSize: <span class="number">30000</span>,</span><br><span class="line">            maxSize: <span class="number">50000</span></span><br><span class="line">        &#125;),</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<p>查看官方 <a href="https://github.com/webpack/webpack/tree/master/examples/http2-aggressive-splitting" target="_blank" rel="external">plugin page</a>，以获得关于更多细节的例子。<a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/preview?pref=2&amp;pli=1" target="_blank" rel="external">学习 HTTP/2 推送实验的课程</a> 和 <a href="https://99designs.com.au/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/" target="_blank" rel="external">真实世界 HTTP/2</a> 也值得一读。</p>
<ul>
<li>渲染初始路由：这实在取决于你使用的框架和库。</li>
<li>预缓存剩下的路由。对于缓存，我们依赖于 Service Worker。<a href="https://github.com/GoogleChrome/sw-precache" target="_blank" rel="external">sw-precache</a> 对于生成用于静态资源预缓存的 Service Worker 很棒，对于 Webpack 我们可以使用 <a href="https://www.npmjs.com/package/sw-precache-webpack-plugin" target="_blank" rel="external">SWPrecacheWebpackPlugin</a>。</li>
<li>按需懒加载并创建剩下的路由 —— 在 Webpack 领域，require.ensure() 和 System.import() 是你的朋友。</li>
</ul>
<h3 id="通过_Webpack_的_Cache-busting_和长期缓存">通过 Webpack 的 Cache-busting 和长期缓存</h3><p><strong>为什么关心静态资源版本？</strong></p>
<p>静态资源指的是我们页面中像是脚本，stylesheets 和图片这样的资源。当用户第一次访问我们页面的时候，他们需要其需要的所有资源。比如说当我们落到一个路由的时候，JavaScript 块和上次访问之际并没有改变 —— 我们不必重新抓取这些脚本因为他们已经在浏览器缓存中存在了。更少的网络请求对 web 性能来说是收益。</p>
<p>通常地，我们使用对每个文件设置 <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en" target="_blank" rel="external">expires 头</a> 来达到目的。一个 expires 头只意味着我们可以告诉浏览器，避免在指定时间内（比如说1年）发起另一个对该文件的请求到服务器。随着代码演变和重新部署，我们想要确保用户可以获得最新的文件，如果没有改变的话则不需要重新下载资源。</p>
<p><a href="https://css-tricks.com/strategies-for-cache-busting-css/" target="_blank" rel="external">Cache-busting</a> 通过在文件名后面附加字符串来完成这个 —— 他可以是一个编译版本（比如 src=”chunk.js?v=1.2.0”），一个 timestamp 或者别的什么。我倾向于添加一个文件内容的 hash 到文件名（比如 chunk.d9834554decb6a8j.js）因为这个在文件内容发生改变的时候总是会改变。MD5 hashing 在 Webpack 社区经常被用来做这个来生成 16 字节长的 ‘概要’。</p>
<p><a href="https://medium.com/@okonetchnikov/long-term-caching-of-static-assets-with-webpack-1ecb139adb95" target="_blank" rel="external"><strong>通过 Webpack 的静态资源长期缓存</strong></a> <strong>是关于这个主题的优秀读物，你应该去看一看。我试图在下面涵盖其涉及到的主要内容。</strong></p>
<p><strong>在 Webpack 中通过内容哈希来做资源版本</strong></p>
<p>在 Webpack 设置中加上如下内容来启用基于内容哈希的资源版本 <a href="https://webpack.github.io/docs/long-term-caching.html" target="_blank" rel="external">[chunkhash]</a>：</p>
<pre><code><span class="attribute">filename</span>: <span class="string">‘[name].[chunkhash].js’,</span>
<span class="attribute">chunkFilename</span>: <span class="string">‘[name].[chunkhash].js’</span>
</code></pre><p>我们也想要保证常规的 [name].js 和 内容哈希 ([name].[chunkhash].js) 文件名在我们的 HTML 文件被正确引用。不同之处在于引用 <code>&lt;script src=”chunk”.js”&gt;</code> 和 <code>&lt;script src=”chunk.d9834554decb6a8j.js”&gt;</code>。</p>
<p>下面是一个注释了的 Webpack 设置样例，包括了一些其他的插件来使得长期缓存的安装更优雅。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 使用 webpack-manifest-plugin 来生成包含了源文件到对应输出的映射的资源 manifest。Webpack 使用 IDs 而不是模块名来保持生成的文件尽量小。IDs 在它们被放进 chunk manifest 之前被生成并映射到 chunk 的文件名（会跑到我们的入口 chunk）。不幸的是，任何对代码的改变都会更新入口 chunk 包括新的 manifest，并刷新我们的缓存。</span></span><br><span class="line"><span class="keyword">const</span> ManifestPlugin = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>);</span><br><span class="line"><span class="comment">// 我们通过 chunk-manifest-webpack-plugin 来修复这个问题，它会将 manifest 放到一个完全独立的 JSON 文件。</span></span><br><span class="line"><span class="keyword">const</span> ChunkManifestPlugin = <span class="built_in">require</span>(<span class="string">'chunk-manifest-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span>,</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">"vendor"</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ManifestPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ChunkManifestPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"chunk-manifest.json"</span>,</span><br><span class="line">      manifestVariable: <span class="string">"webpackManifest"</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 对非确定的模块顺序的权宜之计。在通过 Webpack 的静态资源长期缓存文章中有更多介绍</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们有了这个 chunk-manifest JSON 的编译，我们需要把它内联（inline）到我们的 HTML，那么 Webpack 就能实际在页面启动时真正对其有访问权。所以在 <code>&lt;script&gt;</code> 标签中加上上面的输出。</p>
<p>通过使用 <a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a> 可以实现自动将脚本内联到 HTML 中。</p>
<p>注意：Webpack 理想上可以通过 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="external">no shared ID range</a> 来简化启用长期缓存的步骤（见~4–1）。</p>
<p>如果要学习更多 HTTP 的 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="external">缓存最佳实践</a>，可以阅读 Jake Archibald 的优秀文章。</p>
<h3 id="更多阅读">更多阅读</h3><ul>
<li><a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Webpack 关于代码分割的文档</a></li>
<li>Formidable 的关于 Webpack 的 OSS Playbook <a href="https://formidable.com/open-source/playbook/docs/frontend/webpack-code-splitting/" target="_blank" rel="external">代码分割</a> and <a href="https://formidable.com/open-source/playbook/docs/frontend/webpack-shared-libs/" target="_blank" rel="external">shared libraries</a></li>
<li><a href="http://michalzalecki.com/progressive-web-apps-with-webpack" target="_blank" rel="external">使用 Webpack 的渐进式 Web Apps</a></li>
<li><a href="https://getpocket.com/redirect?url=http%3A%2F%2Fjonathancreamer.com%2Fadvanced-webpack-part-2-code-splitting%2F&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">高级 Webpack Part 2&#8202;—&#8202;代码分割</a></li>
<li><a href="https://medium.com/@lavrton/progressive-loading-for-modern-web-applications-via-code-splitting-fb43999735c6#.1965mrwlr" target="_blank" rel="external">为现代 web 应用程序通过代码分割来渐进加载</a></li>
<li><a href="https://getpocket.com/redirect?url=https%3A%2F%2Ftailordev.fr%2Fblog%2F2016%2F03%2F17%2Floading-dependencies-asynchronously-in-react-components%2F&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">在 React 组件中异步加载依赖</a></li>
<li><a href="https://medium.com/@soederpop/webpack-plugins-been-we-been-keepin-on-the-dll-cdfdd6cb8cd7" target="_blank" rel="external">我们继续前进在 Webpack 插件 DLL</a></li>
<li><a href="https://getpocket.com/redirect?url=https%3A%2F%2Fmedium.com%2Fmodus-create-front-end-development%2Fautomatic-code-splitting-for-react-router-w-es6-imports-a0abdaa491e9%23.twoltv57f&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">自动代码分割用于 React Router 和 ES6 Imports&#8202;—&#8202;Modus Create</a></li>
<li><a href="https://getpocket.com/redirect?url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F34925717%2Fusing-webpack-and-react-router-for-lazyloading-and-code-splitting-not-loading&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">使用 webpack 和 react-router 于懒加载和代码分割没有去加载</a></li>
<li><a href="https://reactjsnews.com/isomorphic-react-in-real-life" target="_blank" rel="external">在现实生活通过 React 同构/通用渲染/路由/数据抓取</a></li>
<li><a href="https://getpocket.com/redirect?url=http%3A%2F%2Fblog.scottlogic.com%2F2016%2F02%2F05%2Fa-lazy-isomorphic-react-experiment.html&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">一个懒得同构 React 实验</a></li>
<li><a href="https://getpocket.com/redirect?url=https%3A%2F%2Fgithub.com%2Fryanflorence%2Fexample-react-router-server-rendering-lazy-routes&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">服务端渲染懒路由</a> 基于 React Router 和代码分割</li>
<li><a href="https://scotch.io/tutorials/react-on-the-server-for-beginners-build-a-universal-react-and-node-app" target="_blank" rel="external">给初学者的 React 在服务端&#8202;—&#8202;构建一个通用的 React app</a></li>
<li><a href="https://getpocket.com/redirect?url=http%3A%2F%2Fblog.mxstbr.com%2F2016%2F01%2Freact-apps-with-pages%2F&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">有页面的 React.js Apps</a></li>
<li><a href="https://getpocket.com/redirect?url=https%3A%2F%2Fwiredcraft.com%2Fblog%2Fcode-splitting-single-page-app%2F&amp;formCheck=0b0d10781e025a205b05e2941ffdc845" target="_blank" rel="external">将世界银行数据网站构建为使用代码分割的快速加载单页应用</a></li>
<li><a href="https://github.com/gatsbyjs/gatsby/issues/431" target="_blank" rel="external">在 Gatsby 实现 PRPL（React.js 静态网站生成器）</a></li>
</ul>
<h4 id="高级模块打包优化读物">高级模块打包优化读物</h4><ul>
<li><a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/" target="_blank" rel="external">模块化的代价</a></li>
<li><a href="https://twitter.com/nolanlawson/status/768525330113925121" target="_blank" rel="external">RollUp 和 Closure Compiler 如何减轻模块的代价</a></li>
<li><a href="https://github.com/samccone/The-cost-of-transpiling-es2015-in-2016" target="_blank" rel="external">在 2016 年转译 ES2015 的代价</a></li>
</ul>
<p>在系列文章第三篇中，我们会来看看 <a href="https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-3-offline-support-and-network-resilience-c84db889162c#.tcspudthd" target="_blank" rel="external"><strong>怎么使你的 React PWA 能离线和断续的网络状态下工作</strong></a>.</p>
<p>如果你新接触 React，我发现 Wes Bos 写的 <a href="https://goo.gl/G1WGxU" target="_blank" rel="external">给新手的 React</a> 很棒。</p>
<p><strong>感谢 Gray Norton, Sean Larkin, Sunil Pai, Max Stoiber, Simon Boudrias, Kyle Mathews 和 Owen Campbell-Moore 的校对。</strong></p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-public-qcode.jpg" alt="Mark Zhai (翟一帆) wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我们的公众号！</div>
</div>


      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/donation.jpg" alt="Mark Zhai (翟一帆) WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/donation-alipay.png" alt="Mark Zhai (翟一帆) Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/PWA/" rel="tag"># PWA</a>
          
            <a href="/tags/React-js/" rel="tag"># React.js</a>
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/01/18/tumblr-like-titlebar-anim/" rel="prev" title="实现Tumblr的标题栏跟滑动渐变颜色（在2个色值之间）的动画">
                实现Tumblr的标题栏跟滑动渐变颜色（在2个色值之间）的动画 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2010/11/14/pwa-react-p2/"
           data-title="使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能" data-url="http://blog.zhaiyifan.cn/2010/11/14/pwa-react-p2/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Mark Zhai (翟一帆)" />
          <p class="site-author-name" itemprop="name">Mark Zhai (翟一帆)</p>
          <p class="site-description motion-element" itemprop="description">白驹过隙 忽然而已</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">62</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/markzhai" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/zhayaofen" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/markzhai" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://zhaiyifan.cn/" target="_blank" title="个人主页">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  个人主页
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://abner-nimengbo.cn" title="Abner泥阿布" target="_blank">Abner泥阿布</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://itangqi.me" title="Qi Tang" target="_blank">Qi Tang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://yifeiyuan.me" title="程序亦非猿" target="_blank">程序亦非猿</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.isming.me/" title="码农明明桑" target="_blank">码农明明桑</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#使用_React-js_的渐进式_Web_应用程序：第_2_部分_-_页面加载性能"><span class="nav-number">1.</span> <span class="nav-text">使用 React.js 的渐进式 Web 应用程序：第 2 部分 - 页面加载性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#新_系列_的第二部分会完整地走一遍怎么使用_Lighthouse-_来优化移动_web_apps。这篇文章，我们来看看页面加载性能。"><span class="nav-number">1.1.</span> <span class="nav-text">新 系列 的第二部分会完整地走一遍怎么使用 Lighthouse. 来优化移动 web apps。这篇文章，我们来看看页面加载性能。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保证页面加载性能是快的"><span class="nav-number">1.1.1.</span> <span class="nav-text">保证页面加载性能是快的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关注抵达可交互时间（TTI）"><span class="nav-number">1.1.2.</span> <span class="nav-text">关注抵达可交互时间（TTI）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于路由分块以提高性能"><span class="nav-number">1.1.3.</span> <span class="nav-text">基于路由分块以提高性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Webpack"><span class="nav-number">1.1.4.</span> <span class="nav-text">Webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践基于路由的代码分块"><span class="nav-number">1.1.5.</span> <span class="nav-text">实践基于路由的代码分块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附录：预加载那些路由！"><span class="nav-number">1.1.6.</span> <span class="nav-text">附录：预加载那些路由！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步加载路由"><span class="nav-number">1.1.7.</span> <span class="nav-text">异步加载路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过异步的_getComponent_+_require-ensure()_的简单宣告式路由分块"><span class="nav-number">1.1.8.</span> <span class="nav-text">通过异步的 getComponent + require.ensure() 的简单宣告式路由分块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CommonsChunkPlugin"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">CommonsChunkPlugin</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码分割（code-splitting）之上：PRPL_模式"><span class="nav-number">1.1.9.</span> <span class="nav-text">代码分割（code-splitting）之上：PRPL 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现_PRPL"><span class="nav-number">1.1.10.</span> <span class="nav-text">实现 PRPL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过_Webpack_的_Cache-busting_和长期缓存"><span class="nav-number">1.1.11.</span> <span class="nav-text">通过 Webpack 的 Cache-busting 和长期缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更多阅读"><span class="nav-number">1.1.12.</span> <span class="nav-text">更多阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高级模块打包优化读物"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">高级模块打包优化读物</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mark Zhai</span>
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"markzhai"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
